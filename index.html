<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Pixel Water Tilt</title>
  <style>
    html,body{height:100%;margin:0;background:#fff;font-family:sans-serif}
    #ui{position:fixed;left:10px;top:10px;z-index:20;background:rgba(0,0,0,0.45);color:#fff;padding:8px;border-radius:8px}
    label{font-size:13px}
    canvas{display:block;width:100%;height:100vh;background:#fff}
  </style>
</head>
<body>
  <div id="ui">
    <label>Grid
      <select id="resSel">
        <option value="64">64</option>
        <option value="96">96</option>
        <option value="128" selected>128</option>
      </select>
    </label>
    <label>Sensitivity
      <input id="sens" type="range" min="10" max="200" value="80" />
    </label>
  </div>

  <canvas id="c"></canvas>

  <script>
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d');
  const resSel = document.getElementById('resSel');
  const sensEl = document.getElementById('sens');

  let W = innerWidth, H = innerHeight;
  canvas.width = W; canvas.height = H;

  let N = +resSel.value;
  let cellW = Math.ceil(W / N), cellH = Math.ceil(H / N);
  let grid;

  // gravity from device tilt
  let gravityX = 0, gravityY = 0;

  function alloc(){
    grid = new Array(N*N).fill(0);
    // fill bottom half with water pixels
    for(let j=Math.floor(N/2); j<N; j++){
      for(let i=0; i<N; i++){
        grid[i+j*N] = 1;
      }
    }
  }

  function IX(x,y){
    return x + y*N;
  }

  function step(){
    let newGrid = new Array(N*N).fill(0);
    const sens = (+sensEl.value)/100;

    for(let j=0;j<N;j++){
      for(let i=0;i<N;i++){
        if(grid[IX(i,j)]>0){
          // compute new pos based on gravity tilt
          let nx = i + Math.sign(gravityX)*sens*0.1;
          let ny = j + Math.sign(gravityY)*sens*0.1;

          nx = Math.max(0, Math.min(N-1, Math.round(nx)));
          ny = Math.max(0, Math.min(N-1, Math.round(ny)));

          newGrid[IX(nx,ny)] = 1;
        }
      }
    }
    grid = newGrid;
  }

  function render(){
    ctx.clearRect(0,0,W,H);
    ctx.strokeStyle = '#000';
    ctx.lineWidth = 0.5;

    // draw grid
    for(let j=0;j<N;j++){
      for(let i=0;i<N;i++){
        ctx.strokeRect(i*cellW, j*cellH, cellW, cellH);
        if(grid[IX(i,j)]>0){
          ctx.fillStyle = 'blue';
          ctx.fillRect(i*cellW, j*cellH, cellW, cellH);
        }
      }
    }
  }

  function loop(){
    step();
    render();
    requestAnimationFrame(loop);
  }

  function handleMotion(e){
    const ag = e.accelerationIncludingGravity || {x:0,y:0,z:0};
    gravityX = ag.x || 0;
    gravityY = -(ag.y || 0);
  }

  async function tryEnableMotion(){
    if(typeof DeviceMotionEvent !== 'undefined' && typeof DeviceMotionEvent.requestPermission === 'function'){
      try{
        const res = await DeviceMotionEvent.requestPermission();
        if(res === 'granted') window.addEventListener('devicemotion', handleMotion);
      }catch(err){ console.log('motion perm error', err); }
    } else {
      window.addEventListener('devicemotion', handleMotion);
    }
  }

  function onResize(){
    W = innerWidth; H = innerHeight; canvas.width = W; canvas.height = H;
    N = +resSel.value;
    cellW = Math.ceil(W / N); cellH = Math.ceil(H / N);
    alloc();
  }

  resSel.addEventListener('change', ()=> onResize());
  window.addEventListener('resize', ()=> onResize());

  onResize();
  tryEnableMotion();
  loop();
  </script>
</body>
</html>
